Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL

Grammar

Rule 0     S' -> codeLine
Rule 1     codeLine -> suite
Rule 2     suite -> stmt
Rule 3     suite -> stmt suite
Rule 4     stmt -> exprStmt
Rule 5     stmt -> declar
Rule 6     stmt -> call SEMCOL
Rule 7     stmt -> selectionStmt
Rule 8     stmt -> iterationStmt
Rule 9     stmt -> returnStmt SEMCOL
Rule 10    stmt -> inputStmt SEMCOL
Rule 11    stmt -> outputStmt SEMCOL
Rule 12    stmt -> lineComment
Rule 13    stmt -> blockComment
Rule 14    declar -> varDeclar SEMCOL
Rule 15    declar -> funcDeclar
Rule 16    varDeclar -> VAR ID ASSIGN STRING
Rule 17    varDeclar -> LET ID ASSIGN STRING
Rule 18    varDeclar -> VAR ID ASSIGN exprStmt
Rule 19    varDeclar -> LET ID ASSIGN exprStmt
Rule 20    varDeclar -> VAR ID ASSIGN inputStmt
Rule 21    varDeclar -> LET ID ASSIGN inputStmt
Rule 22    varDeclar -> ID ASSIGN exprStmt
Rule 23    funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK
Rule 24    funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
Rule 25    params -> paramsList
Rule 26    paramsList -> ID COMA paramsList
Rule 27    paramsList -> ID
Rule 28    call -> ID
Rule 29    call -> ID POINT call
Rule 30    call -> ID LPARENT RPARENT
Rule 31    call -> ID LPARENT params RPARENT
Rule 32    call -> call POINT call
Rule 33    exprStmt -> simpleExpr
Rule 34    selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
Rule 35    selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
Rule 36    iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
Rule 37    returnStmt -> RETURN
Rule 38    returnStmt -> RETURN simpleExpr
Rule 39    simpleExpr -> simpleExpr OR andExpr
Rule 40    simpleExpr -> andExpr
Rule 41    andExpr -> andExpr AND unaryRelExpr
Rule 42    andExpr -> unaryRelExpr
Rule 43    unaryRelExpr -> NOT unaryRelExpr
Rule 44    unaryRelExpr -> relExpr
Rule 45    relExpr -> sumExpr relop sumExpr
Rule 46    relExpr -> sumExpr
Rule 47    relop -> LOET
Rule 48    relop -> LT
Rule 49    relop -> GOET
Rule 50    relop -> GT
Rule 51    relop -> EQ
Rule 52    relop -> NEQ
Rule 53    sumExpr -> sumExpr sumop term
Rule 54    sumExpr -> term
Rule 55    sumop -> SUM
Rule 56    sumop -> SUBST
Rule 57    term -> term mulop opElement
Rule 58    term -> opElement
Rule 59    opElement -> call
Rule 60    opElement -> NUMBER
Rule 61    mulop -> PROD
Rule 62    mulop -> DIV
Rule 63    inputStmt -> READLINE LPARENT RPARENT
Rule 64    outputStmt -> PRINT LPARENT STRING RPARENT
Rule 65    lineComment -> LINE_COMMENT
Rule 66    blockComment -> BLOCK_COMMENT

Terminals, with rules where they appear

AND                  : 41
ASSIGN               : 16 17 18 19 20 21 22
BLOCK_COMMENT        : 66
BOOL                 : 
COMA                 : 26
DIV                  : 62
ELSE                 : 35
EQ                   : 51
FUNC                 : 23 24
GOET                 : 49
GT                   : 50
ID                   : 16 17 18 19 20 21 22 23 24 26 27 28 29 30 31
IF                   : 34 35
LBRACK               : 23 24 34 35 35 36
LET                  : 17 19 21
LINE_COMMENT         : 65
LOET                 : 47
LPARENT              : 23 24 30 31 34 35 36 63 64
LT                   : 48
NEQ                  : 52
NOT                  : 43
NUMBER               : 60
OR                   : 39
POINT                : 29 32
PRINT                : 64
PROD                 : 61
RBRACK               : 23 24 34 35 35 36
READLINE             : 63
RETURN               : 37 38
RPARENT              : 23 24 30 31 34 35 36 63 64
SEMCOL               : 6 9 10 11 14
STRING               : 16 17 64
SUBST                : 56
SUM                  : 55
VAR                  : 16 18 20
WHILE                : 36
error                : 

Nonterminals, with rules where they appear

andExpr              : 39 40 41
blockComment         : 13
call                 : 6 29 32 32 59
codeLine             : 0
declar               : 5
exprStmt             : 4 18 19 22
funcDeclar           : 15
inputStmt            : 10 20 21
iterationStmt        : 8
lineComment          : 12
mulop                : 57
opElement            : 57 58
outputStmt           : 11
params               : 24 31
paramsList           : 25 26
relExpr              : 44
relop                : 45
returnStmt           : 9
selectionStmt        : 7
simpleExpr           : 33 34 35 36 38 39
stmt                 : 2 3
suite                : 1 3 23 24 34 35 35 36
sumExpr              : 45 45 46 53
sumop                : 53
term                 : 53 54 57
unaryRelExpr         : 41 42 43
varDeclar            : 14

Parsing method: LALR

state 0

    (0) S' -> . codeLine
    (1) codeLine -> . suite
    (2) suite -> . stmt
    (3) suite -> . stmt suite
    (4) stmt -> . exprStmt
    (5) stmt -> . declar
    (6) stmt -> . call SEMCOL
    (7) stmt -> . selectionStmt
    (8) stmt -> . iterationStmt
    (9) stmt -> . returnStmt SEMCOL
    (10) stmt -> . inputStmt SEMCOL
    (11) stmt -> . outputStmt SEMCOL
    (12) stmt -> . lineComment
    (13) stmt -> . blockComment
    (33) exprStmt -> . simpleExpr
    (14) declar -> . varDeclar SEMCOL
    (15) declar -> . funcDeclar
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call
    (34) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (36) iterationStmt -> . WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (37) returnStmt -> . RETURN
    (38) returnStmt -> . RETURN simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (64) outputStmt -> . PRINT LPARENT STRING RPARENT
    (65) lineComment -> . LINE_COMMENT
    (66) blockComment -> . BLOCK_COMMENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (16) varDeclar -> . VAR ID ASSIGN STRING
    (17) varDeclar -> . LET ID ASSIGN STRING
    (18) varDeclar -> . VAR ID ASSIGN exprStmt
    (19) varDeclar -> . LET ID ASSIGN exprStmt
    (20) varDeclar -> . VAR ID ASSIGN inputStmt
    (21) varDeclar -> . LET ID ASSIGN inputStmt
    (22) varDeclar -> . ID ASSIGN exprStmt
    (23) funcDeclar -> . FUNC ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> . FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER

    ID              shift and go to state 22
    IF              shift and go to state 19
    WHILE           shift and go to state 9
    RETURN          shift and go to state 23
    READLINE        shift and go to state 16
    PRINT           shift and go to state 7
    LINE_COMMENT    shift and go to state 8
    BLOCK_COMMENT   shift and go to state 28
    VAR             shift and go to state 26
    LET             shift and go to state 12
    FUNC            shift and go to state 17
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30

    codeLine                       shift and go to state 18
    sumExpr                        shift and go to state 5
    funcDeclar                     shift and go to state 1
    outputStmt                     shift and go to state 20
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    inputStmt                      shift and go to state 4
    suite                          shift and go to state 24
    declar                         shift and go to state 29
    call                           shift and go to state 6
    simpleExpr                     shift and go to state 3
    andExpr                        shift and go to state 27
    relExpr                        shift and go to state 10
    selectionStmt                  shift and go to state 11
    exprStmt                       shift and go to state 14
    returnStmt                     shift and go to state 31
    lineComment                    shift and go to state 13
    unaryRelExpr                   shift and go to state 33
    iterationStmt                  shift and go to state 15
    blockComment                   shift and go to state 34
    varDeclar                      shift and go to state 32
    stmt                           shift and go to state 35

state 1

    (15) declar -> funcDeclar .

    ID              reduce using rule 15 (declar -> funcDeclar .)
    IF              reduce using rule 15 (declar -> funcDeclar .)
    WHILE           reduce using rule 15 (declar -> funcDeclar .)
    RETURN          reduce using rule 15 (declar -> funcDeclar .)
    READLINE        reduce using rule 15 (declar -> funcDeclar .)
    PRINT           reduce using rule 15 (declar -> funcDeclar .)
    LINE_COMMENT    reduce using rule 15 (declar -> funcDeclar .)
    BLOCK_COMMENT   reduce using rule 15 (declar -> funcDeclar .)
    VAR             reduce using rule 15 (declar -> funcDeclar .)
    LET             reduce using rule 15 (declar -> funcDeclar .)
    FUNC            reduce using rule 15 (declar -> funcDeclar .)
    NOT             reduce using rule 15 (declar -> funcDeclar .)
    NUMBER          reduce using rule 15 (declar -> funcDeclar .)
    $end            reduce using rule 15 (declar -> funcDeclar .)
    RBRACK          reduce using rule 15 (declar -> funcDeclar .)


state 2

    (54) sumExpr -> term .
    (57) term -> term . mulop opElement
    (61) mulop -> . PROD
    (62) mulop -> . DIV

    LOET            reduce using rule 54 (sumExpr -> term .)
    LT              reduce using rule 54 (sumExpr -> term .)
    GOET            reduce using rule 54 (sumExpr -> term .)
    GT              reduce using rule 54 (sumExpr -> term .)
    EQ              reduce using rule 54 (sumExpr -> term .)
    NEQ             reduce using rule 54 (sumExpr -> term .)
    SUM             reduce using rule 54 (sumExpr -> term .)
    SUBST           reduce using rule 54 (sumExpr -> term .)
    AND             reduce using rule 54 (sumExpr -> term .)
    RPARENT         reduce using rule 54 (sumExpr -> term .)
    OR              reduce using rule 54 (sumExpr -> term .)
    ID              reduce using rule 54 (sumExpr -> term .)
    IF              reduce using rule 54 (sumExpr -> term .)
    WHILE           reduce using rule 54 (sumExpr -> term .)
    RETURN          reduce using rule 54 (sumExpr -> term .)
    READLINE        reduce using rule 54 (sumExpr -> term .)
    PRINT           reduce using rule 54 (sumExpr -> term .)
    LINE_COMMENT    reduce using rule 54 (sumExpr -> term .)
    BLOCK_COMMENT   reduce using rule 54 (sumExpr -> term .)
    VAR             reduce using rule 54 (sumExpr -> term .)
    LET             reduce using rule 54 (sumExpr -> term .)
    FUNC            reduce using rule 54 (sumExpr -> term .)
    NOT             reduce using rule 54 (sumExpr -> term .)
    NUMBER          reduce using rule 54 (sumExpr -> term .)
    RBRACK          reduce using rule 54 (sumExpr -> term .)
    SEMCOL          reduce using rule 54 (sumExpr -> term .)
    $end            reduce using rule 54 (sumExpr -> term .)
    PROD            shift and go to state 36
    DIV             shift and go to state 37

    mulop                          shift and go to state 38

state 3

    (33) exprStmt -> simpleExpr .
    (39) simpleExpr -> simpleExpr . OR andExpr

    ID              reduce using rule 33 (exprStmt -> simpleExpr .)
    IF              reduce using rule 33 (exprStmt -> simpleExpr .)
    WHILE           reduce using rule 33 (exprStmt -> simpleExpr .)
    RETURN          reduce using rule 33 (exprStmt -> simpleExpr .)
    READLINE        reduce using rule 33 (exprStmt -> simpleExpr .)
    PRINT           reduce using rule 33 (exprStmt -> simpleExpr .)
    LINE_COMMENT    reduce using rule 33 (exprStmt -> simpleExpr .)
    BLOCK_COMMENT   reduce using rule 33 (exprStmt -> simpleExpr .)
    VAR             reduce using rule 33 (exprStmt -> simpleExpr .)
    LET             reduce using rule 33 (exprStmt -> simpleExpr .)
    FUNC            reduce using rule 33 (exprStmt -> simpleExpr .)
    NOT             reduce using rule 33 (exprStmt -> simpleExpr .)
    NUMBER          reduce using rule 33 (exprStmt -> simpleExpr .)
    RBRACK          reduce using rule 33 (exprStmt -> simpleExpr .)
    SEMCOL          reduce using rule 33 (exprStmt -> simpleExpr .)
    $end            reduce using rule 33 (exprStmt -> simpleExpr .)
    OR              shift and go to state 39


state 4

    (10) stmt -> inputStmt . SEMCOL

    SEMCOL          shift and go to state 40


state 5

    (45) relExpr -> sumExpr . relop sumExpr
    (46) relExpr -> sumExpr .
    (53) sumExpr -> sumExpr . sumop term
    (47) relop -> . LOET
    (48) relop -> . LT
    (49) relop -> . GOET
    (50) relop -> . GT
    (51) relop -> . EQ
    (52) relop -> . NEQ
    (55) sumop -> . SUM
    (56) sumop -> . SUBST

    AND             reduce using rule 46 (relExpr -> sumExpr .)
    OR              reduce using rule 46 (relExpr -> sumExpr .)
    ID              reduce using rule 46 (relExpr -> sumExpr .)
    IF              reduce using rule 46 (relExpr -> sumExpr .)
    WHILE           reduce using rule 46 (relExpr -> sumExpr .)
    RETURN          reduce using rule 46 (relExpr -> sumExpr .)
    READLINE        reduce using rule 46 (relExpr -> sumExpr .)
    PRINT           reduce using rule 46 (relExpr -> sumExpr .)
    LINE_COMMENT    reduce using rule 46 (relExpr -> sumExpr .)
    BLOCK_COMMENT   reduce using rule 46 (relExpr -> sumExpr .)
    VAR             reduce using rule 46 (relExpr -> sumExpr .)
    LET             reduce using rule 46 (relExpr -> sumExpr .)
    FUNC            reduce using rule 46 (relExpr -> sumExpr .)
    NOT             reduce using rule 46 (relExpr -> sumExpr .)
    NUMBER          reduce using rule 46 (relExpr -> sumExpr .)
    RBRACK          reduce using rule 46 (relExpr -> sumExpr .)
    SEMCOL          reduce using rule 46 (relExpr -> sumExpr .)
    RPARENT         reduce using rule 46 (relExpr -> sumExpr .)
    $end            reduce using rule 46 (relExpr -> sumExpr .)
    LOET            shift and go to state 43
    LT              shift and go to state 49
    GOET            shift and go to state 44
    GT              shift and go to state 42
    EQ              shift and go to state 50
    NEQ             shift and go to state 45
    SUM             shift and go to state 41
    SUBST           shift and go to state 48

    sumop                          shift and go to state 46
    relop                          shift and go to state 47

state 6

    (6) stmt -> call . SEMCOL
    (32) call -> call . POINT call
    (59) opElement -> call .

    SEMCOL          shift and go to state 51
    POINT           shift and go to state 52
    PROD            reduce using rule 59 (opElement -> call .)
    DIV             reduce using rule 59 (opElement -> call .)
    LOET            reduce using rule 59 (opElement -> call .)
    LT              reduce using rule 59 (opElement -> call .)
    GOET            reduce using rule 59 (opElement -> call .)
    GT              reduce using rule 59 (opElement -> call .)
    EQ              reduce using rule 59 (opElement -> call .)
    NEQ             reduce using rule 59 (opElement -> call .)
    SUM             reduce using rule 59 (opElement -> call .)
    SUBST           reduce using rule 59 (opElement -> call .)
    AND             reduce using rule 59 (opElement -> call .)
    OR              reduce using rule 59 (opElement -> call .)
    ID              reduce using rule 59 (opElement -> call .)
    IF              reduce using rule 59 (opElement -> call .)
    WHILE           reduce using rule 59 (opElement -> call .)
    RETURN          reduce using rule 59 (opElement -> call .)
    READLINE        reduce using rule 59 (opElement -> call .)
    PRINT           reduce using rule 59 (opElement -> call .)
    LINE_COMMENT    reduce using rule 59 (opElement -> call .)
    BLOCK_COMMENT   reduce using rule 59 (opElement -> call .)
    VAR             reduce using rule 59 (opElement -> call .)
    LET             reduce using rule 59 (opElement -> call .)
    FUNC            reduce using rule 59 (opElement -> call .)
    NOT             reduce using rule 59 (opElement -> call .)
    NUMBER          reduce using rule 59 (opElement -> call .)
    RBRACK          reduce using rule 59 (opElement -> call .)
    $end            reduce using rule 59 (opElement -> call .)


state 7

    (64) outputStmt -> PRINT . LPARENT STRING RPARENT

    LPARENT         shift and go to state 53


state 8

    (65) lineComment -> LINE_COMMENT .

    ID              reduce using rule 65 (lineComment -> LINE_COMMENT .)
    IF              reduce using rule 65 (lineComment -> LINE_COMMENT .)
    WHILE           reduce using rule 65 (lineComment -> LINE_COMMENT .)
    RETURN          reduce using rule 65 (lineComment -> LINE_COMMENT .)
    READLINE        reduce using rule 65 (lineComment -> LINE_COMMENT .)
    PRINT           reduce using rule 65 (lineComment -> LINE_COMMENT .)
    LINE_COMMENT    reduce using rule 65 (lineComment -> LINE_COMMENT .)
    BLOCK_COMMENT   reduce using rule 65 (lineComment -> LINE_COMMENT .)
    VAR             reduce using rule 65 (lineComment -> LINE_COMMENT .)
    LET             reduce using rule 65 (lineComment -> LINE_COMMENT .)
    FUNC            reduce using rule 65 (lineComment -> LINE_COMMENT .)
    NOT             reduce using rule 65 (lineComment -> LINE_COMMENT .)
    NUMBER          reduce using rule 65 (lineComment -> LINE_COMMENT .)
    RBRACK          reduce using rule 65 (lineComment -> LINE_COMMENT .)
    $end            reduce using rule 65 (lineComment -> LINE_COMMENT .)


state 9

    (36) iterationStmt -> WHILE . LPARENT simpleExpr RPARENT LBRACK suite RBRACK

    LPARENT         shift and go to state 54


state 10

    (44) unaryRelExpr -> relExpr .

    AND             reduce using rule 44 (unaryRelExpr -> relExpr .)
    OR              reduce using rule 44 (unaryRelExpr -> relExpr .)
    SEMCOL          reduce using rule 44 (unaryRelExpr -> relExpr .)
    ID              reduce using rule 44 (unaryRelExpr -> relExpr .)
    IF              reduce using rule 44 (unaryRelExpr -> relExpr .)
    WHILE           reduce using rule 44 (unaryRelExpr -> relExpr .)
    RETURN          reduce using rule 44 (unaryRelExpr -> relExpr .)
    READLINE        reduce using rule 44 (unaryRelExpr -> relExpr .)
    PRINT           reduce using rule 44 (unaryRelExpr -> relExpr .)
    LINE_COMMENT    reduce using rule 44 (unaryRelExpr -> relExpr .)
    BLOCK_COMMENT   reduce using rule 44 (unaryRelExpr -> relExpr .)
    VAR             reduce using rule 44 (unaryRelExpr -> relExpr .)
    LET             reduce using rule 44 (unaryRelExpr -> relExpr .)
    FUNC            reduce using rule 44 (unaryRelExpr -> relExpr .)
    NOT             reduce using rule 44 (unaryRelExpr -> relExpr .)
    NUMBER          reduce using rule 44 (unaryRelExpr -> relExpr .)
    $end            reduce using rule 44 (unaryRelExpr -> relExpr .)
    RBRACK          reduce using rule 44 (unaryRelExpr -> relExpr .)
    RPARENT         reduce using rule 44 (unaryRelExpr -> relExpr .)


state 11

    (7) stmt -> selectionStmt .

    ID              reduce using rule 7 (stmt -> selectionStmt .)
    IF              reduce using rule 7 (stmt -> selectionStmt .)
    WHILE           reduce using rule 7 (stmt -> selectionStmt .)
    RETURN          reduce using rule 7 (stmt -> selectionStmt .)
    READLINE        reduce using rule 7 (stmt -> selectionStmt .)
    PRINT           reduce using rule 7 (stmt -> selectionStmt .)
    LINE_COMMENT    reduce using rule 7 (stmt -> selectionStmt .)
    BLOCK_COMMENT   reduce using rule 7 (stmt -> selectionStmt .)
    VAR             reduce using rule 7 (stmt -> selectionStmt .)
    LET             reduce using rule 7 (stmt -> selectionStmt .)
    FUNC            reduce using rule 7 (stmt -> selectionStmt .)
    NOT             reduce using rule 7 (stmt -> selectionStmt .)
    NUMBER          reduce using rule 7 (stmt -> selectionStmt .)
    RBRACK          reduce using rule 7 (stmt -> selectionStmt .)
    $end            reduce using rule 7 (stmt -> selectionStmt .)


state 12

    (17) varDeclar -> LET . ID ASSIGN STRING
    (19) varDeclar -> LET . ID ASSIGN exprStmt
    (21) varDeclar -> LET . ID ASSIGN inputStmt

    ID              shift and go to state 55


state 13

    (12) stmt -> lineComment .

    ID              reduce using rule 12 (stmt -> lineComment .)
    IF              reduce using rule 12 (stmt -> lineComment .)
    WHILE           reduce using rule 12 (stmt -> lineComment .)
    RETURN          reduce using rule 12 (stmt -> lineComment .)
    READLINE        reduce using rule 12 (stmt -> lineComment .)
    PRINT           reduce using rule 12 (stmt -> lineComment .)
    LINE_COMMENT    reduce using rule 12 (stmt -> lineComment .)
    BLOCK_COMMENT   reduce using rule 12 (stmt -> lineComment .)
    VAR             reduce using rule 12 (stmt -> lineComment .)
    LET             reduce using rule 12 (stmt -> lineComment .)
    FUNC            reduce using rule 12 (stmt -> lineComment .)
    NOT             reduce using rule 12 (stmt -> lineComment .)
    NUMBER          reduce using rule 12 (stmt -> lineComment .)
    RBRACK          reduce using rule 12 (stmt -> lineComment .)
    $end            reduce using rule 12 (stmt -> lineComment .)


state 14

    (4) stmt -> exprStmt .

    ID              reduce using rule 4 (stmt -> exprStmt .)
    IF              reduce using rule 4 (stmt -> exprStmt .)
    WHILE           reduce using rule 4 (stmt -> exprStmt .)
    RETURN          reduce using rule 4 (stmt -> exprStmt .)
    READLINE        reduce using rule 4 (stmt -> exprStmt .)
    PRINT           reduce using rule 4 (stmt -> exprStmt .)
    LINE_COMMENT    reduce using rule 4 (stmt -> exprStmt .)
    BLOCK_COMMENT   reduce using rule 4 (stmt -> exprStmt .)
    VAR             reduce using rule 4 (stmt -> exprStmt .)
    LET             reduce using rule 4 (stmt -> exprStmt .)
    FUNC            reduce using rule 4 (stmt -> exprStmt .)
    NOT             reduce using rule 4 (stmt -> exprStmt .)
    NUMBER          reduce using rule 4 (stmt -> exprStmt .)
    RBRACK          reduce using rule 4 (stmt -> exprStmt .)
    $end            reduce using rule 4 (stmt -> exprStmt .)


state 15

    (8) stmt -> iterationStmt .

    ID              reduce using rule 8 (stmt -> iterationStmt .)
    IF              reduce using rule 8 (stmt -> iterationStmt .)
    WHILE           reduce using rule 8 (stmt -> iterationStmt .)
    RETURN          reduce using rule 8 (stmt -> iterationStmt .)
    READLINE        reduce using rule 8 (stmt -> iterationStmt .)
    PRINT           reduce using rule 8 (stmt -> iterationStmt .)
    LINE_COMMENT    reduce using rule 8 (stmt -> iterationStmt .)
    BLOCK_COMMENT   reduce using rule 8 (stmt -> iterationStmt .)
    VAR             reduce using rule 8 (stmt -> iterationStmt .)
    LET             reduce using rule 8 (stmt -> iterationStmt .)
    FUNC            reduce using rule 8 (stmt -> iterationStmt .)
    NOT             reduce using rule 8 (stmt -> iterationStmt .)
    NUMBER          reduce using rule 8 (stmt -> iterationStmt .)
    RBRACK          reduce using rule 8 (stmt -> iterationStmt .)
    $end            reduce using rule 8 (stmt -> iterationStmt .)


state 16

    (63) inputStmt -> READLINE . LPARENT RPARENT

    LPARENT         shift and go to state 56


state 17

    (23) funcDeclar -> FUNC . ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> FUNC . ID LPARENT params RPARENT LBRACK suite RBRACK

    ID              shift and go to state 57


state 18

    (0) S' -> codeLine .



state 19

    (34) selectionStmt -> IF . LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> IF . LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK

    LPARENT         shift and go to state 58


state 20

    (11) stmt -> outputStmt . SEMCOL

    SEMCOL          shift and go to state 59


state 21

    (58) term -> opElement .

    PROD            reduce using rule 58 (term -> opElement .)
    DIV             reduce using rule 58 (term -> opElement .)
    LOET            reduce using rule 58 (term -> opElement .)
    LT              reduce using rule 58 (term -> opElement .)
    GOET            reduce using rule 58 (term -> opElement .)
    GT              reduce using rule 58 (term -> opElement .)
    EQ              reduce using rule 58 (term -> opElement .)
    NEQ             reduce using rule 58 (term -> opElement .)
    SUM             reduce using rule 58 (term -> opElement .)
    SUBST           reduce using rule 58 (term -> opElement .)
    AND             reduce using rule 58 (term -> opElement .)
    OR              reduce using rule 58 (term -> opElement .)
    SEMCOL          reduce using rule 58 (term -> opElement .)
    ID              reduce using rule 58 (term -> opElement .)
    IF              reduce using rule 58 (term -> opElement .)
    WHILE           reduce using rule 58 (term -> opElement .)
    RETURN          reduce using rule 58 (term -> opElement .)
    READLINE        reduce using rule 58 (term -> opElement .)
    PRINT           reduce using rule 58 (term -> opElement .)
    LINE_COMMENT    reduce using rule 58 (term -> opElement .)
    BLOCK_COMMENT   reduce using rule 58 (term -> opElement .)
    VAR             reduce using rule 58 (term -> opElement .)
    LET             reduce using rule 58 (term -> opElement .)
    FUNC            reduce using rule 58 (term -> opElement .)
    NOT             reduce using rule 58 (term -> opElement .)
    NUMBER          reduce using rule 58 (term -> opElement .)
    RBRACK          reduce using rule 58 (term -> opElement .)
    $end            reduce using rule 58 (term -> opElement .)
    RPARENT         reduce using rule 58 (term -> opElement .)


state 22

    (28) call -> ID .
    (29) call -> ID . POINT call
    (30) call -> ID . LPARENT RPARENT
    (31) call -> ID . LPARENT params RPARENT
    (22) varDeclar -> ID . ASSIGN exprStmt

  ! shift/reduce conflict for POINT resolved as shift
    SEMCOL          reduce using rule 28 (call -> ID .)
    PROD            reduce using rule 28 (call -> ID .)
    DIV             reduce using rule 28 (call -> ID .)
    LOET            reduce using rule 28 (call -> ID .)
    LT              reduce using rule 28 (call -> ID .)
    GOET            reduce using rule 28 (call -> ID .)
    GT              reduce using rule 28 (call -> ID .)
    EQ              reduce using rule 28 (call -> ID .)
    NEQ             reduce using rule 28 (call -> ID .)
    SUM             reduce using rule 28 (call -> ID .)
    SUBST           reduce using rule 28 (call -> ID .)
    AND             reduce using rule 28 (call -> ID .)
    OR              reduce using rule 28 (call -> ID .)
    ID              reduce using rule 28 (call -> ID .)
    IF              reduce using rule 28 (call -> ID .)
    WHILE           reduce using rule 28 (call -> ID .)
    RETURN          reduce using rule 28 (call -> ID .)
    READLINE        reduce using rule 28 (call -> ID .)
    PRINT           reduce using rule 28 (call -> ID .)
    LINE_COMMENT    reduce using rule 28 (call -> ID .)
    BLOCK_COMMENT   reduce using rule 28 (call -> ID .)
    VAR             reduce using rule 28 (call -> ID .)
    LET             reduce using rule 28 (call -> ID .)
    FUNC            reduce using rule 28 (call -> ID .)
    NOT             reduce using rule 28 (call -> ID .)
    NUMBER          reduce using rule 28 (call -> ID .)
    $end            reduce using rule 28 (call -> ID .)
    RBRACK          reduce using rule 28 (call -> ID .)
    POINT           shift and go to state 62
    LPARENT         shift and go to state 61
    ASSIGN          shift and go to state 60

  ! POINT           [ reduce using rule 28 (call -> ID .) ]


state 23

    (37) returnStmt -> RETURN .
    (38) returnStmt -> RETURN . simpleExpr
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    SEMCOL          reduce using rule 37 (returnStmt -> RETURN .)
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    andExpr                        shift and go to state 27
    sumExpr                        shift and go to state 5
    opElement                      shift and go to state 21
    relExpr                        shift and go to state 10
    term                           shift and go to state 2
    unaryRelExpr                   shift and go to state 33
    call                           shift and go to state 64
    simpleExpr                     shift and go to state 63

state 24

    (1) codeLine -> suite .

    $end            reduce using rule 1 (codeLine -> suite .)


state 25

    (43) unaryRelExpr -> NOT . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    call                           shift and go to state 64
    unaryRelExpr                   shift and go to state 66
    opElement                      shift and go to state 21
    sumExpr                        shift and go to state 5
    relExpr                        shift and go to state 10
    term                           shift and go to state 2

state 26

    (16) varDeclar -> VAR . ID ASSIGN STRING
    (18) varDeclar -> VAR . ID ASSIGN exprStmt
    (20) varDeclar -> VAR . ID ASSIGN inputStmt

    ID              shift and go to state 67


state 27

    (40) simpleExpr -> andExpr .
    (41) andExpr -> andExpr . AND unaryRelExpr

    OR              reduce using rule 40 (simpleExpr -> andExpr .)
    ID              reduce using rule 40 (simpleExpr -> andExpr .)
    IF              reduce using rule 40 (simpleExpr -> andExpr .)
    WHILE           reduce using rule 40 (simpleExpr -> andExpr .)
    RETURN          reduce using rule 40 (simpleExpr -> andExpr .)
    READLINE        reduce using rule 40 (simpleExpr -> andExpr .)
    PRINT           reduce using rule 40 (simpleExpr -> andExpr .)
    LINE_COMMENT    reduce using rule 40 (simpleExpr -> andExpr .)
    BLOCK_COMMENT   reduce using rule 40 (simpleExpr -> andExpr .)
    VAR             reduce using rule 40 (simpleExpr -> andExpr .)
    LET             reduce using rule 40 (simpleExpr -> andExpr .)
    FUNC            reduce using rule 40 (simpleExpr -> andExpr .)
    NOT             reduce using rule 40 (simpleExpr -> andExpr .)
    NUMBER          reduce using rule 40 (simpleExpr -> andExpr .)
    RBRACK          reduce using rule 40 (simpleExpr -> andExpr .)
    $end            reduce using rule 40 (simpleExpr -> andExpr .)
    SEMCOL          reduce using rule 40 (simpleExpr -> andExpr .)
    RPARENT         reduce using rule 40 (simpleExpr -> andExpr .)
    AND             shift and go to state 68


state 28

    (66) blockComment -> BLOCK_COMMENT .

    ID              reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    IF              reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    WHILE           reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    RETURN          reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    READLINE        reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    PRINT           reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    LINE_COMMENT    reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    BLOCK_COMMENT   reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    VAR             reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    LET             reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    FUNC            reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    NOT             reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    NUMBER          reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    RBRACK          reduce using rule 66 (blockComment -> BLOCK_COMMENT .)
    $end            reduce using rule 66 (blockComment -> BLOCK_COMMENT .)


state 29

    (5) stmt -> declar .

    ID              reduce using rule 5 (stmt -> declar .)
    IF              reduce using rule 5 (stmt -> declar .)
    WHILE           reduce using rule 5 (stmt -> declar .)
    RETURN          reduce using rule 5 (stmt -> declar .)
    READLINE        reduce using rule 5 (stmt -> declar .)
    PRINT           reduce using rule 5 (stmt -> declar .)
    LINE_COMMENT    reduce using rule 5 (stmt -> declar .)
    BLOCK_COMMENT   reduce using rule 5 (stmt -> declar .)
    VAR             reduce using rule 5 (stmt -> declar .)
    LET             reduce using rule 5 (stmt -> declar .)
    FUNC            reduce using rule 5 (stmt -> declar .)
    NOT             reduce using rule 5 (stmt -> declar .)
    NUMBER          reduce using rule 5 (stmt -> declar .)
    RBRACK          reduce using rule 5 (stmt -> declar .)
    $end            reduce using rule 5 (stmt -> declar .)


state 30

    (60) opElement -> NUMBER .

    PROD            reduce using rule 60 (opElement -> NUMBER .)
    DIV             reduce using rule 60 (opElement -> NUMBER .)
    LOET            reduce using rule 60 (opElement -> NUMBER .)
    LT              reduce using rule 60 (opElement -> NUMBER .)
    GOET            reduce using rule 60 (opElement -> NUMBER .)
    GT              reduce using rule 60 (opElement -> NUMBER .)
    EQ              reduce using rule 60 (opElement -> NUMBER .)
    NEQ             reduce using rule 60 (opElement -> NUMBER .)
    SUM             reduce using rule 60 (opElement -> NUMBER .)
    SUBST           reduce using rule 60 (opElement -> NUMBER .)
    AND             reduce using rule 60 (opElement -> NUMBER .)
    OR              reduce using rule 60 (opElement -> NUMBER .)
    ID              reduce using rule 60 (opElement -> NUMBER .)
    IF              reduce using rule 60 (opElement -> NUMBER .)
    WHILE           reduce using rule 60 (opElement -> NUMBER .)
    RETURN          reduce using rule 60 (opElement -> NUMBER .)
    READLINE        reduce using rule 60 (opElement -> NUMBER .)
    PRINT           reduce using rule 60 (opElement -> NUMBER .)
    LINE_COMMENT    reduce using rule 60 (opElement -> NUMBER .)
    BLOCK_COMMENT   reduce using rule 60 (opElement -> NUMBER .)
    VAR             reduce using rule 60 (opElement -> NUMBER .)
    LET             reduce using rule 60 (opElement -> NUMBER .)
    FUNC            reduce using rule 60 (opElement -> NUMBER .)
    NOT             reduce using rule 60 (opElement -> NUMBER .)
    NUMBER          reduce using rule 60 (opElement -> NUMBER .)
    $end            reduce using rule 60 (opElement -> NUMBER .)
    SEMCOL          reduce using rule 60 (opElement -> NUMBER .)
    RBRACK          reduce using rule 60 (opElement -> NUMBER .)
    RPARENT         reduce using rule 60 (opElement -> NUMBER .)


state 31

    (9) stmt -> returnStmt . SEMCOL

    SEMCOL          shift and go to state 69


state 32

    (14) declar -> varDeclar . SEMCOL

    SEMCOL          shift and go to state 70


state 33

    (42) andExpr -> unaryRelExpr .

    AND             reduce using rule 42 (andExpr -> unaryRelExpr .)
    RPARENT         reduce using rule 42 (andExpr -> unaryRelExpr .)
    OR              reduce using rule 42 (andExpr -> unaryRelExpr .)
    SEMCOL          reduce using rule 42 (andExpr -> unaryRelExpr .)
    ID              reduce using rule 42 (andExpr -> unaryRelExpr .)
    IF              reduce using rule 42 (andExpr -> unaryRelExpr .)
    WHILE           reduce using rule 42 (andExpr -> unaryRelExpr .)
    RETURN          reduce using rule 42 (andExpr -> unaryRelExpr .)
    READLINE        reduce using rule 42 (andExpr -> unaryRelExpr .)
    PRINT           reduce using rule 42 (andExpr -> unaryRelExpr .)
    LINE_COMMENT    reduce using rule 42 (andExpr -> unaryRelExpr .)
    BLOCK_COMMENT   reduce using rule 42 (andExpr -> unaryRelExpr .)
    VAR             reduce using rule 42 (andExpr -> unaryRelExpr .)
    LET             reduce using rule 42 (andExpr -> unaryRelExpr .)
    FUNC            reduce using rule 42 (andExpr -> unaryRelExpr .)
    NOT             reduce using rule 42 (andExpr -> unaryRelExpr .)
    NUMBER          reduce using rule 42 (andExpr -> unaryRelExpr .)
    $end            reduce using rule 42 (andExpr -> unaryRelExpr .)
    RBRACK          reduce using rule 42 (andExpr -> unaryRelExpr .)


state 34

    (13) stmt -> blockComment .

    ID              reduce using rule 13 (stmt -> blockComment .)
    IF              reduce using rule 13 (stmt -> blockComment .)
    WHILE           reduce using rule 13 (stmt -> blockComment .)
    RETURN          reduce using rule 13 (stmt -> blockComment .)
    READLINE        reduce using rule 13 (stmt -> blockComment .)
    PRINT           reduce using rule 13 (stmt -> blockComment .)
    LINE_COMMENT    reduce using rule 13 (stmt -> blockComment .)
    BLOCK_COMMENT   reduce using rule 13 (stmt -> blockComment .)
    VAR             reduce using rule 13 (stmt -> blockComment .)
    LET             reduce using rule 13 (stmt -> blockComment .)
    FUNC            reduce using rule 13 (stmt -> blockComment .)
    NOT             reduce using rule 13 (stmt -> blockComment .)
    NUMBER          reduce using rule 13 (stmt -> blockComment .)
    RBRACK          reduce using rule 13 (stmt -> blockComment .)
    $end            reduce using rule 13 (stmt -> blockComment .)


state 35

    (2) suite -> stmt .
    (3) suite -> stmt . suite
    (2) suite -> . stmt
    (3) suite -> . stmt suite
    (4) stmt -> . exprStmt
    (5) stmt -> . declar
    (6) stmt -> . call SEMCOL
    (7) stmt -> . selectionStmt
    (8) stmt -> . iterationStmt
    (9) stmt -> . returnStmt SEMCOL
    (10) stmt -> . inputStmt SEMCOL
    (11) stmt -> . outputStmt SEMCOL
    (12) stmt -> . lineComment
    (13) stmt -> . blockComment
    (33) exprStmt -> . simpleExpr
    (14) declar -> . varDeclar SEMCOL
    (15) declar -> . funcDeclar
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call
    (34) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (36) iterationStmt -> . WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (37) returnStmt -> . RETURN
    (38) returnStmt -> . RETURN simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (64) outputStmt -> . PRINT LPARENT STRING RPARENT
    (65) lineComment -> . LINE_COMMENT
    (66) blockComment -> . BLOCK_COMMENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (16) varDeclar -> . VAR ID ASSIGN STRING
    (17) varDeclar -> . LET ID ASSIGN STRING
    (18) varDeclar -> . VAR ID ASSIGN exprStmt
    (19) varDeclar -> . LET ID ASSIGN exprStmt
    (20) varDeclar -> . VAR ID ASSIGN inputStmt
    (21) varDeclar -> . LET ID ASSIGN inputStmt
    (22) varDeclar -> . ID ASSIGN exprStmt
    (23) funcDeclar -> . FUNC ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> . FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER

    $end            reduce using rule 2 (suite -> stmt .)
    RBRACK          reduce using rule 2 (suite -> stmt .)
    ID              shift and go to state 22
    IF              shift and go to state 19
    WHILE           shift and go to state 9
    RETURN          shift and go to state 23
    READLINE        shift and go to state 16
    PRINT           shift and go to state 7
    LINE_COMMENT    shift and go to state 8
    BLOCK_COMMENT   shift and go to state 28
    VAR             shift and go to state 26
    LET             shift and go to state 12
    FUNC            shift and go to state 17
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30

    sumExpr                        shift and go to state 5
    funcDeclar                     shift and go to state 1
    outputStmt                     shift and go to state 20
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    inputStmt                      shift and go to state 4
    suite                          shift and go to state 71
    declar                         shift and go to state 29
    call                           shift and go to state 6
    simpleExpr                     shift and go to state 3
    andExpr                        shift and go to state 27
    relExpr                        shift and go to state 10
    selectionStmt                  shift and go to state 11
    exprStmt                       shift and go to state 14
    returnStmt                     shift and go to state 31
    lineComment                    shift and go to state 13
    unaryRelExpr                   shift and go to state 33
    iterationStmt                  shift and go to state 15
    blockComment                   shift and go to state 34
    varDeclar                      shift and go to state 32
    stmt                           shift and go to state 35

state 36

    (61) mulop -> PROD .

    NUMBER          reduce using rule 61 (mulop -> PROD .)
    ID              reduce using rule 61 (mulop -> PROD .)


state 37

    (62) mulop -> DIV .

    NUMBER          reduce using rule 62 (mulop -> DIV .)
    ID              reduce using rule 62 (mulop -> DIV .)


state 38

    (57) term -> term mulop . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    call                           shift and go to state 64
    opElement                      shift and go to state 72

state 39

    (39) simpleExpr -> simpleExpr OR . andExpr
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    andExpr                        shift and go to state 73
    sumExpr                        shift and go to state 5
    opElement                      shift and go to state 21
    relExpr                        shift and go to state 10
    term                           shift and go to state 2
    unaryRelExpr                   shift and go to state 33
    call                           shift and go to state 64

state 40

    (10) stmt -> inputStmt SEMCOL .

    ID              reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    IF              reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    WHILE           reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    RETURN          reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    READLINE        reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    PRINT           reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    LINE_COMMENT    reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    BLOCK_COMMENT   reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    VAR             reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    LET             reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    FUNC            reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    NOT             reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    NUMBER          reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    RBRACK          reduce using rule 10 (stmt -> inputStmt SEMCOL .)
    $end            reduce using rule 10 (stmt -> inputStmt SEMCOL .)


state 41

    (55) sumop -> SUM .

    NUMBER          reduce using rule 55 (sumop -> SUM .)
    ID              reduce using rule 55 (sumop -> SUM .)


state 42

    (50) relop -> GT .

    NUMBER          reduce using rule 50 (relop -> GT .)
    ID              reduce using rule 50 (relop -> GT .)


state 43

    (47) relop -> LOET .

    NUMBER          reduce using rule 47 (relop -> LOET .)
    ID              reduce using rule 47 (relop -> LOET .)


state 44

    (49) relop -> GOET .

    NUMBER          reduce using rule 49 (relop -> GOET .)
    ID              reduce using rule 49 (relop -> GOET .)


state 45

    (52) relop -> NEQ .

    NUMBER          reduce using rule 52 (relop -> NEQ .)
    ID              reduce using rule 52 (relop -> NEQ .)


state 46

    (53) sumExpr -> sumExpr sumop . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    call                           shift and go to state 64
    opElement                      shift and go to state 21
    term                           shift and go to state 74

state 47

    (45) relExpr -> sumExpr relop . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    call                           shift and go to state 64
    opElement                      shift and go to state 21
    sumExpr                        shift and go to state 75
    term                           shift and go to state 2

state 48

    (56) sumop -> SUBST .

    NUMBER          reduce using rule 56 (sumop -> SUBST .)
    ID              reduce using rule 56 (sumop -> SUBST .)


state 49

    (48) relop -> LT .

    NUMBER          reduce using rule 48 (relop -> LT .)
    ID              reduce using rule 48 (relop -> LT .)


state 50

    (51) relop -> EQ .

    NUMBER          reduce using rule 51 (relop -> EQ .)
    ID              reduce using rule 51 (relop -> EQ .)


state 51

    (6) stmt -> call SEMCOL .

    ID              reduce using rule 6 (stmt -> call SEMCOL .)
    IF              reduce using rule 6 (stmt -> call SEMCOL .)
    WHILE           reduce using rule 6 (stmt -> call SEMCOL .)
    RETURN          reduce using rule 6 (stmt -> call SEMCOL .)
    READLINE        reduce using rule 6 (stmt -> call SEMCOL .)
    PRINT           reduce using rule 6 (stmt -> call SEMCOL .)
    LINE_COMMENT    reduce using rule 6 (stmt -> call SEMCOL .)
    BLOCK_COMMENT   reduce using rule 6 (stmt -> call SEMCOL .)
    VAR             reduce using rule 6 (stmt -> call SEMCOL .)
    LET             reduce using rule 6 (stmt -> call SEMCOL .)
    FUNC            reduce using rule 6 (stmt -> call SEMCOL .)
    NOT             reduce using rule 6 (stmt -> call SEMCOL .)
    NUMBER          reduce using rule 6 (stmt -> call SEMCOL .)
    RBRACK          reduce using rule 6 (stmt -> call SEMCOL .)
    $end            reduce using rule 6 (stmt -> call SEMCOL .)


state 52

    (32) call -> call POINT . call
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    ID              shift and go to state 65

    call                           shift and go to state 76

state 53

    (64) outputStmt -> PRINT LPARENT . STRING RPARENT

    STRING          shift and go to state 77


state 54

    (36) iterationStmt -> WHILE LPARENT . simpleExpr RPARENT LBRACK suite RBRACK
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    andExpr                        shift and go to state 27
    sumExpr                        shift and go to state 5
    opElement                      shift and go to state 21
    relExpr                        shift and go to state 10
    term                           shift and go to state 2
    unaryRelExpr                   shift and go to state 33
    call                           shift and go to state 64
    simpleExpr                     shift and go to state 78

state 55

    (17) varDeclar -> LET ID . ASSIGN STRING
    (19) varDeclar -> LET ID . ASSIGN exprStmt
    (21) varDeclar -> LET ID . ASSIGN inputStmt

    ASSIGN          shift and go to state 79


state 56

    (63) inputStmt -> READLINE LPARENT . RPARENT

    RPARENT         shift and go to state 80


state 57

    (23) funcDeclar -> FUNC ID . LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> FUNC ID . LPARENT params RPARENT LBRACK suite RBRACK

    LPARENT         shift and go to state 81


state 58

    (34) selectionStmt -> IF LPARENT . simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> IF LPARENT . simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    andExpr                        shift and go to state 27
    sumExpr                        shift and go to state 5
    opElement                      shift and go to state 21
    relExpr                        shift and go to state 10
    term                           shift and go to state 2
    unaryRelExpr                   shift and go to state 33
    call                           shift and go to state 64
    simpleExpr                     shift and go to state 82

state 59

    (11) stmt -> outputStmt SEMCOL .

    ID              reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    IF              reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    WHILE           reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    RETURN          reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    READLINE        reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    PRINT           reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    LINE_COMMENT    reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    BLOCK_COMMENT   reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    VAR             reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    LET             reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    FUNC            reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    NOT             reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    NUMBER          reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    RBRACK          reduce using rule 11 (stmt -> outputStmt SEMCOL .)
    $end            reduce using rule 11 (stmt -> outputStmt SEMCOL .)


state 60

    (22) varDeclar -> ID ASSIGN . exprStmt
    (33) exprStmt -> . simpleExpr
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    andExpr                        shift and go to state 27
    sumExpr                        shift and go to state 5
    relExpr                        shift and go to state 10
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    exprStmt                       shift and go to state 83
    unaryRelExpr                   shift and go to state 33
    call                           shift and go to state 64
    simpleExpr                     shift and go to state 3

state 61

    (30) call -> ID LPARENT . RPARENT
    (31) call -> ID LPARENT . params RPARENT
    (25) params -> . paramsList
    (26) paramsList -> . ID COMA paramsList
    (27) paramsList -> . ID

    RPARENT         shift and go to state 86
    ID              shift and go to state 85

    paramsList                     shift and go to state 84
    params                         shift and go to state 87

state 62

    (29) call -> ID POINT . call
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    ID              shift and go to state 65

    call                           shift and go to state 88

state 63

    (38) returnStmt -> RETURN simpleExpr .
    (39) simpleExpr -> simpleExpr . OR andExpr

    SEMCOL          reduce using rule 38 (returnStmt -> RETURN simpleExpr .)
    OR              shift and go to state 39


state 64

    (59) opElement -> call .
    (32) call -> call . POINT call

    PROD            reduce using rule 59 (opElement -> call .)
    DIV             reduce using rule 59 (opElement -> call .)
    LOET            reduce using rule 59 (opElement -> call .)
    LT              reduce using rule 59 (opElement -> call .)
    GOET            reduce using rule 59 (opElement -> call .)
    GT              reduce using rule 59 (opElement -> call .)
    EQ              reduce using rule 59 (opElement -> call .)
    NEQ             reduce using rule 59 (opElement -> call .)
    SUM             reduce using rule 59 (opElement -> call .)
    SUBST           reduce using rule 59 (opElement -> call .)
    AND             reduce using rule 59 (opElement -> call .)
    OR              reduce using rule 59 (opElement -> call .)
    ID              reduce using rule 59 (opElement -> call .)
    IF              reduce using rule 59 (opElement -> call .)
    WHILE           reduce using rule 59 (opElement -> call .)
    RETURN          reduce using rule 59 (opElement -> call .)
    READLINE        reduce using rule 59 (opElement -> call .)
    PRINT           reduce using rule 59 (opElement -> call .)
    LINE_COMMENT    reduce using rule 59 (opElement -> call .)
    BLOCK_COMMENT   reduce using rule 59 (opElement -> call .)
    VAR             reduce using rule 59 (opElement -> call .)
    LET             reduce using rule 59 (opElement -> call .)
    FUNC            reduce using rule 59 (opElement -> call .)
    NOT             reduce using rule 59 (opElement -> call .)
    NUMBER          reduce using rule 59 (opElement -> call .)
    $end            reduce using rule 59 (opElement -> call .)
    SEMCOL          reduce using rule 59 (opElement -> call .)
    RBRACK          reduce using rule 59 (opElement -> call .)
    RPARENT         reduce using rule 59 (opElement -> call .)
    POINT           shift and go to state 52


state 65

    (28) call -> ID .
    (29) call -> ID . POINT call
    (30) call -> ID . LPARENT RPARENT
    (31) call -> ID . LPARENT params RPARENT

  ! shift/reduce conflict for POINT resolved as shift
    PROD            reduce using rule 28 (call -> ID .)
    DIV             reduce using rule 28 (call -> ID .)
    LOET            reduce using rule 28 (call -> ID .)
    LT              reduce using rule 28 (call -> ID .)
    GOET            reduce using rule 28 (call -> ID .)
    GT              reduce using rule 28 (call -> ID .)
    EQ              reduce using rule 28 (call -> ID .)
    NEQ             reduce using rule 28 (call -> ID .)
    SUM             reduce using rule 28 (call -> ID .)
    SUBST           reduce using rule 28 (call -> ID .)
    AND             reduce using rule 28 (call -> ID .)
    RPARENT         reduce using rule 28 (call -> ID .)
    OR              reduce using rule 28 (call -> ID .)
    ID              reduce using rule 28 (call -> ID .)
    IF              reduce using rule 28 (call -> ID .)
    WHILE           reduce using rule 28 (call -> ID .)
    RETURN          reduce using rule 28 (call -> ID .)
    READLINE        reduce using rule 28 (call -> ID .)
    PRINT           reduce using rule 28 (call -> ID .)
    LINE_COMMENT    reduce using rule 28 (call -> ID .)
    BLOCK_COMMENT   reduce using rule 28 (call -> ID .)
    VAR             reduce using rule 28 (call -> ID .)
    LET             reduce using rule 28 (call -> ID .)
    FUNC            reduce using rule 28 (call -> ID .)
    NOT             reduce using rule 28 (call -> ID .)
    NUMBER          reduce using rule 28 (call -> ID .)
    $end            reduce using rule 28 (call -> ID .)
    SEMCOL          reduce using rule 28 (call -> ID .)
    RBRACK          reduce using rule 28 (call -> ID .)
    POINT           shift and go to state 62
    LPARENT         shift and go to state 61

  ! POINT           [ reduce using rule 28 (call -> ID .) ]


state 66

    (43) unaryRelExpr -> NOT unaryRelExpr .

    AND             reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    OR              reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    SEMCOL          reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    ID              reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    IF              reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    WHILE           reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    RETURN          reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    READLINE        reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    PRINT           reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    LINE_COMMENT    reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    BLOCK_COMMENT   reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    VAR             reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    LET             reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    FUNC            reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    NOT             reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    NUMBER          reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    $end            reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    RBRACK          reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)
    RPARENT         reduce using rule 43 (unaryRelExpr -> NOT unaryRelExpr .)


state 67

    (16) varDeclar -> VAR ID . ASSIGN STRING
    (18) varDeclar -> VAR ID . ASSIGN exprStmt
    (20) varDeclar -> VAR ID . ASSIGN inputStmt

    ASSIGN          shift and go to state 89


state 68

    (41) andExpr -> andExpr AND . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    sumExpr                        shift and go to state 5
    call                           shift and go to state 64
    unaryRelExpr                   shift and go to state 90
    opElement                      shift and go to state 21
    relExpr                        shift and go to state 10
    term                           shift and go to state 2

state 69

    (9) stmt -> returnStmt SEMCOL .

    ID              reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    IF              reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    WHILE           reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    RETURN          reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    READLINE        reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    PRINT           reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    LINE_COMMENT    reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    BLOCK_COMMENT   reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    VAR             reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    LET             reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    FUNC            reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    NOT             reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    NUMBER          reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    RBRACK          reduce using rule 9 (stmt -> returnStmt SEMCOL .)
    $end            reduce using rule 9 (stmt -> returnStmt SEMCOL .)


state 70

    (14) declar -> varDeclar SEMCOL .

    ID              reduce using rule 14 (declar -> varDeclar SEMCOL .)
    IF              reduce using rule 14 (declar -> varDeclar SEMCOL .)
    WHILE           reduce using rule 14 (declar -> varDeclar SEMCOL .)
    RETURN          reduce using rule 14 (declar -> varDeclar SEMCOL .)
    READLINE        reduce using rule 14 (declar -> varDeclar SEMCOL .)
    PRINT           reduce using rule 14 (declar -> varDeclar SEMCOL .)
    LINE_COMMENT    reduce using rule 14 (declar -> varDeclar SEMCOL .)
    BLOCK_COMMENT   reduce using rule 14 (declar -> varDeclar SEMCOL .)
    VAR             reduce using rule 14 (declar -> varDeclar SEMCOL .)
    LET             reduce using rule 14 (declar -> varDeclar SEMCOL .)
    FUNC            reduce using rule 14 (declar -> varDeclar SEMCOL .)
    NOT             reduce using rule 14 (declar -> varDeclar SEMCOL .)
    NUMBER          reduce using rule 14 (declar -> varDeclar SEMCOL .)
    $end            reduce using rule 14 (declar -> varDeclar SEMCOL .)
    RBRACK          reduce using rule 14 (declar -> varDeclar SEMCOL .)


state 71

    (3) suite -> stmt suite .

    $end            reduce using rule 3 (suite -> stmt suite .)
    RBRACK          reduce using rule 3 (suite -> stmt suite .)


state 72

    (57) term -> term mulop opElement .

    PROD            reduce using rule 57 (term -> term mulop opElement .)
    DIV             reduce using rule 57 (term -> term mulop opElement .)
    LOET            reduce using rule 57 (term -> term mulop opElement .)
    LT              reduce using rule 57 (term -> term mulop opElement .)
    GOET            reduce using rule 57 (term -> term mulop opElement .)
    GT              reduce using rule 57 (term -> term mulop opElement .)
    EQ              reduce using rule 57 (term -> term mulop opElement .)
    NEQ             reduce using rule 57 (term -> term mulop opElement .)
    SUM             reduce using rule 57 (term -> term mulop opElement .)
    SUBST           reduce using rule 57 (term -> term mulop opElement .)
    AND             reduce using rule 57 (term -> term mulop opElement .)
    OR              reduce using rule 57 (term -> term mulop opElement .)
    SEMCOL          reduce using rule 57 (term -> term mulop opElement .)
    ID              reduce using rule 57 (term -> term mulop opElement .)
    IF              reduce using rule 57 (term -> term mulop opElement .)
    WHILE           reduce using rule 57 (term -> term mulop opElement .)
    RETURN          reduce using rule 57 (term -> term mulop opElement .)
    READLINE        reduce using rule 57 (term -> term mulop opElement .)
    PRINT           reduce using rule 57 (term -> term mulop opElement .)
    LINE_COMMENT    reduce using rule 57 (term -> term mulop opElement .)
    BLOCK_COMMENT   reduce using rule 57 (term -> term mulop opElement .)
    VAR             reduce using rule 57 (term -> term mulop opElement .)
    LET             reduce using rule 57 (term -> term mulop opElement .)
    FUNC            reduce using rule 57 (term -> term mulop opElement .)
    NOT             reduce using rule 57 (term -> term mulop opElement .)
    NUMBER          reduce using rule 57 (term -> term mulop opElement .)
    RBRACK          reduce using rule 57 (term -> term mulop opElement .)
    $end            reduce using rule 57 (term -> term mulop opElement .)
    RPARENT         reduce using rule 57 (term -> term mulop opElement .)


state 73

    (39) simpleExpr -> simpleExpr OR andExpr .
    (41) andExpr -> andExpr . AND unaryRelExpr

    OR              reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    ID              reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    IF              reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    WHILE           reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    RETURN          reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    READLINE        reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    PRINT           reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    LINE_COMMENT    reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    BLOCK_COMMENT   reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    VAR             reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    LET             reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    FUNC            reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    NOT             reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    NUMBER          reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    RBRACK          reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    $end            reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    SEMCOL          reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    RPARENT         reduce using rule 39 (simpleExpr -> simpleExpr OR andExpr .)
    AND             shift and go to state 68


state 74

    (53) sumExpr -> sumExpr sumop term .
    (57) term -> term . mulop opElement
    (61) mulop -> . PROD
    (62) mulop -> . DIV

    LOET            reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    LT              reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    GOET            reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    GT              reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    EQ              reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    NEQ             reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    SUM             reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    SUBST           reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    AND             reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    RPARENT         reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    OR              reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    ID              reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    IF              reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    WHILE           reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    RETURN          reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    READLINE        reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    PRINT           reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    LINE_COMMENT    reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    BLOCK_COMMENT   reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    VAR             reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    LET             reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    FUNC            reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    NOT             reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    NUMBER          reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    RBRACK          reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    SEMCOL          reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    $end            reduce using rule 53 (sumExpr -> sumExpr sumop term .)
    PROD            shift and go to state 36
    DIV             shift and go to state 37

    mulop                          shift and go to state 38

state 75

    (45) relExpr -> sumExpr relop sumExpr .
    (53) sumExpr -> sumExpr . sumop term
    (55) sumop -> . SUM
    (56) sumop -> . SUBST

    AND             reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    OR              reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    ID              reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    IF              reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    WHILE           reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    RETURN          reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    READLINE        reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    PRINT           reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    LINE_COMMENT    reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    BLOCK_COMMENT   reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    VAR             reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    LET             reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    FUNC            reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    NOT             reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    NUMBER          reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    RBRACK          reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    SEMCOL          reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    RPARENT         reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    $end            reduce using rule 45 (relExpr -> sumExpr relop sumExpr .)
    SUM             shift and go to state 41
    SUBST           shift and go to state 48

    sumop                          shift and go to state 46

state 76

    (32) call -> call POINT call .
    (32) call -> call . POINT call

  ! shift/reduce conflict for POINT resolved as shift
    PROD            reduce using rule 32 (call -> call POINT call .)
    DIV             reduce using rule 32 (call -> call POINT call .)
    LOET            reduce using rule 32 (call -> call POINT call .)
    LT              reduce using rule 32 (call -> call POINT call .)
    GOET            reduce using rule 32 (call -> call POINT call .)
    GT              reduce using rule 32 (call -> call POINT call .)
    EQ              reduce using rule 32 (call -> call POINT call .)
    NEQ             reduce using rule 32 (call -> call POINT call .)
    SUM             reduce using rule 32 (call -> call POINT call .)
    SUBST           reduce using rule 32 (call -> call POINT call .)
    AND             reduce using rule 32 (call -> call POINT call .)
    RPARENT         reduce using rule 32 (call -> call POINT call .)
    OR              reduce using rule 32 (call -> call POINT call .)
    SEMCOL          reduce using rule 32 (call -> call POINT call .)
    ID              reduce using rule 32 (call -> call POINT call .)
    IF              reduce using rule 32 (call -> call POINT call .)
    WHILE           reduce using rule 32 (call -> call POINT call .)
    RETURN          reduce using rule 32 (call -> call POINT call .)
    READLINE        reduce using rule 32 (call -> call POINT call .)
    PRINT           reduce using rule 32 (call -> call POINT call .)
    LINE_COMMENT    reduce using rule 32 (call -> call POINT call .)
    BLOCK_COMMENT   reduce using rule 32 (call -> call POINT call .)
    VAR             reduce using rule 32 (call -> call POINT call .)
    LET             reduce using rule 32 (call -> call POINT call .)
    FUNC            reduce using rule 32 (call -> call POINT call .)
    NOT             reduce using rule 32 (call -> call POINT call .)
    NUMBER          reduce using rule 32 (call -> call POINT call .)
    $end            reduce using rule 32 (call -> call POINT call .)
    RBRACK          reduce using rule 32 (call -> call POINT call .)
    POINT           shift and go to state 52

  ! POINT           [ reduce using rule 32 (call -> call POINT call .) ]


state 77

    (64) outputStmt -> PRINT LPARENT STRING . RPARENT

    RPARENT         shift and go to state 91


state 78

    (36) iterationStmt -> WHILE LPARENT simpleExpr . RPARENT LBRACK suite RBRACK
    (39) simpleExpr -> simpleExpr . OR andExpr

    RPARENT         shift and go to state 92
    OR              shift and go to state 39


state 79

    (17) varDeclar -> LET ID ASSIGN . STRING
    (19) varDeclar -> LET ID ASSIGN . exprStmt
    (21) varDeclar -> LET ID ASSIGN . inputStmt
    (33) exprStmt -> . simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    STRING          shift and go to state 94
    READLINE        shift and go to state 16
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    andExpr                        shift and go to state 27
    sumExpr                        shift and go to state 5
    relExpr                        shift and go to state 10
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    exprStmt                       shift and go to state 95
    inputStmt                      shift and go to state 93
    unaryRelExpr                   shift and go to state 33
    call                           shift and go to state 64
    simpleExpr                     shift and go to state 3

state 80

    (63) inputStmt -> READLINE LPARENT RPARENT .

    SEMCOL          reduce using rule 63 (inputStmt -> READLINE LPARENT RPARENT .)


state 81

    (23) funcDeclar -> FUNC ID LPARENT . RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> FUNC ID LPARENT . params RPARENT LBRACK suite RBRACK
    (25) params -> . paramsList
    (26) paramsList -> . ID COMA paramsList
    (27) paramsList -> . ID

    RPARENT         shift and go to state 96
    ID              shift and go to state 85

    paramsList                     shift and go to state 84
    params                         shift and go to state 97

state 82

    (34) selectionStmt -> IF LPARENT simpleExpr . RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> IF LPARENT simpleExpr . RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (39) simpleExpr -> simpleExpr . OR andExpr

    RPARENT         shift and go to state 98
    OR              shift and go to state 39


state 83

    (22) varDeclar -> ID ASSIGN exprStmt .

    SEMCOL          reduce using rule 22 (varDeclar -> ID ASSIGN exprStmt .)


state 84

    (25) params -> paramsList .

    RPARENT         reduce using rule 25 (params -> paramsList .)


state 85

    (26) paramsList -> ID . COMA paramsList
    (27) paramsList -> ID .

    COMA            shift and go to state 99
    RPARENT         reduce using rule 27 (paramsList -> ID .)


state 86

    (30) call -> ID LPARENT RPARENT .

    POINT           reduce using rule 30 (call -> ID LPARENT RPARENT .)
    PROD            reduce using rule 30 (call -> ID LPARENT RPARENT .)
    DIV             reduce using rule 30 (call -> ID LPARENT RPARENT .)
    LOET            reduce using rule 30 (call -> ID LPARENT RPARENT .)
    LT              reduce using rule 30 (call -> ID LPARENT RPARENT .)
    GOET            reduce using rule 30 (call -> ID LPARENT RPARENT .)
    GT              reduce using rule 30 (call -> ID LPARENT RPARENT .)
    EQ              reduce using rule 30 (call -> ID LPARENT RPARENT .)
    NEQ             reduce using rule 30 (call -> ID LPARENT RPARENT .)
    SUM             reduce using rule 30 (call -> ID LPARENT RPARENT .)
    SUBST           reduce using rule 30 (call -> ID LPARENT RPARENT .)
    AND             reduce using rule 30 (call -> ID LPARENT RPARENT .)
    RPARENT         reduce using rule 30 (call -> ID LPARENT RPARENT .)
    OR              reduce using rule 30 (call -> ID LPARENT RPARENT .)
    SEMCOL          reduce using rule 30 (call -> ID LPARENT RPARENT .)
    ID              reduce using rule 30 (call -> ID LPARENT RPARENT .)
    IF              reduce using rule 30 (call -> ID LPARENT RPARENT .)
    WHILE           reduce using rule 30 (call -> ID LPARENT RPARENT .)
    RETURN          reduce using rule 30 (call -> ID LPARENT RPARENT .)
    READLINE        reduce using rule 30 (call -> ID LPARENT RPARENT .)
    PRINT           reduce using rule 30 (call -> ID LPARENT RPARENT .)
    LINE_COMMENT    reduce using rule 30 (call -> ID LPARENT RPARENT .)
    BLOCK_COMMENT   reduce using rule 30 (call -> ID LPARENT RPARENT .)
    VAR             reduce using rule 30 (call -> ID LPARENT RPARENT .)
    LET             reduce using rule 30 (call -> ID LPARENT RPARENT .)
    FUNC            reduce using rule 30 (call -> ID LPARENT RPARENT .)
    NOT             reduce using rule 30 (call -> ID LPARENT RPARENT .)
    NUMBER          reduce using rule 30 (call -> ID LPARENT RPARENT .)
    $end            reduce using rule 30 (call -> ID LPARENT RPARENT .)
    RBRACK          reduce using rule 30 (call -> ID LPARENT RPARENT .)


state 87

    (31) call -> ID LPARENT params . RPARENT

    RPARENT         shift and go to state 100


state 88

    (29) call -> ID POINT call .
    (32) call -> call . POINT call

  ! shift/reduce conflict for POINT resolved as shift
    PROD            reduce using rule 29 (call -> ID POINT call .)
    DIV             reduce using rule 29 (call -> ID POINT call .)
    LOET            reduce using rule 29 (call -> ID POINT call .)
    LT              reduce using rule 29 (call -> ID POINT call .)
    GOET            reduce using rule 29 (call -> ID POINT call .)
    GT              reduce using rule 29 (call -> ID POINT call .)
    EQ              reduce using rule 29 (call -> ID POINT call .)
    NEQ             reduce using rule 29 (call -> ID POINT call .)
    SUM             reduce using rule 29 (call -> ID POINT call .)
    SUBST           reduce using rule 29 (call -> ID POINT call .)
    AND             reduce using rule 29 (call -> ID POINT call .)
    RPARENT         reduce using rule 29 (call -> ID POINT call .)
    OR              reduce using rule 29 (call -> ID POINT call .)
    SEMCOL          reduce using rule 29 (call -> ID POINT call .)
    ID              reduce using rule 29 (call -> ID POINT call .)
    IF              reduce using rule 29 (call -> ID POINT call .)
    WHILE           reduce using rule 29 (call -> ID POINT call .)
    RETURN          reduce using rule 29 (call -> ID POINT call .)
    READLINE        reduce using rule 29 (call -> ID POINT call .)
    PRINT           reduce using rule 29 (call -> ID POINT call .)
    LINE_COMMENT    reduce using rule 29 (call -> ID POINT call .)
    BLOCK_COMMENT   reduce using rule 29 (call -> ID POINT call .)
    VAR             reduce using rule 29 (call -> ID POINT call .)
    LET             reduce using rule 29 (call -> ID POINT call .)
    FUNC            reduce using rule 29 (call -> ID POINT call .)
    NOT             reduce using rule 29 (call -> ID POINT call .)
    NUMBER          reduce using rule 29 (call -> ID POINT call .)
    $end            reduce using rule 29 (call -> ID POINT call .)
    RBRACK          reduce using rule 29 (call -> ID POINT call .)
    POINT           shift and go to state 52

  ! POINT           [ reduce using rule 29 (call -> ID POINT call .) ]


state 89

    (16) varDeclar -> VAR ID ASSIGN . STRING
    (18) varDeclar -> VAR ID ASSIGN . exprStmt
    (20) varDeclar -> VAR ID ASSIGN . inputStmt
    (33) exprStmt -> . simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call

    STRING          shift and go to state 102
    READLINE        shift and go to state 16
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30
    ID              shift and go to state 65

    andExpr                        shift and go to state 27
    sumExpr                        shift and go to state 5
    relExpr                        shift and go to state 10
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    exprStmt                       shift and go to state 103
    inputStmt                      shift and go to state 101
    unaryRelExpr                   shift and go to state 33
    call                           shift and go to state 64
    simpleExpr                     shift and go to state 3

state 90

    (41) andExpr -> andExpr AND unaryRelExpr .

    AND             reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    RPARENT         reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    OR              reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    SEMCOL          reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    ID              reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    IF              reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    WHILE           reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    RETURN          reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    READLINE        reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    PRINT           reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    LINE_COMMENT    reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    BLOCK_COMMENT   reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    VAR             reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    LET             reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    FUNC            reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    NOT             reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    NUMBER          reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    $end            reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)
    RBRACK          reduce using rule 41 (andExpr -> andExpr AND unaryRelExpr .)


state 91

    (64) outputStmt -> PRINT LPARENT STRING RPARENT .

    SEMCOL          reduce using rule 64 (outputStmt -> PRINT LPARENT STRING RPARENT .)


state 92

    (36) iterationStmt -> WHILE LPARENT simpleExpr RPARENT . LBRACK suite RBRACK

    LBRACK          shift and go to state 104


state 93

    (21) varDeclar -> LET ID ASSIGN inputStmt .

    SEMCOL          reduce using rule 21 (varDeclar -> LET ID ASSIGN inputStmt .)


state 94

    (17) varDeclar -> LET ID ASSIGN STRING .

    SEMCOL          reduce using rule 17 (varDeclar -> LET ID ASSIGN STRING .)


state 95

    (19) varDeclar -> LET ID ASSIGN exprStmt .

    SEMCOL          reduce using rule 19 (varDeclar -> LET ID ASSIGN exprStmt .)


state 96

    (23) funcDeclar -> FUNC ID LPARENT RPARENT . LBRACK suite RBRACK

    LBRACK          shift and go to state 105


state 97

    (24) funcDeclar -> FUNC ID LPARENT params . RPARENT LBRACK suite RBRACK

    RPARENT         shift and go to state 106


state 98

    (34) selectionStmt -> IF LPARENT simpleExpr RPARENT . LBRACK suite RBRACK
    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT . LBRACK suite RBRACK ELSE LBRACK suite RBRACK

    LBRACK          shift and go to state 107


state 99

    (26) paramsList -> ID COMA . paramsList
    (26) paramsList -> . ID COMA paramsList
    (27) paramsList -> . ID

    ID              shift and go to state 85

    paramsList                     shift and go to state 108

state 100

    (31) call -> ID LPARENT params RPARENT .

    POINT           reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    PROD            reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    DIV             reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    LOET            reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    LT              reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    GOET            reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    GT              reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    EQ              reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    NEQ             reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    SUM             reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    SUBST           reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    AND             reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    RPARENT         reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    OR              reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    SEMCOL          reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    ID              reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    IF              reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    WHILE           reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    RETURN          reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    READLINE        reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    PRINT           reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    LINE_COMMENT    reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    BLOCK_COMMENT   reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    VAR             reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    LET             reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    FUNC            reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    NOT             reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    NUMBER          reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    $end            reduce using rule 31 (call -> ID LPARENT params RPARENT .)
    RBRACK          reduce using rule 31 (call -> ID LPARENT params RPARENT .)


state 101

    (20) varDeclar -> VAR ID ASSIGN inputStmt .

    SEMCOL          reduce using rule 20 (varDeclar -> VAR ID ASSIGN inputStmt .)


state 102

    (16) varDeclar -> VAR ID ASSIGN STRING .

    SEMCOL          reduce using rule 16 (varDeclar -> VAR ID ASSIGN STRING .)


state 103

    (18) varDeclar -> VAR ID ASSIGN exprStmt .

    SEMCOL          reduce using rule 18 (varDeclar -> VAR ID ASSIGN exprStmt .)


state 104

    (36) iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK . suite RBRACK
    (2) suite -> . stmt
    (3) suite -> . stmt suite
    (4) stmt -> . exprStmt
    (5) stmt -> . declar
    (6) stmt -> . call SEMCOL
    (7) stmt -> . selectionStmt
    (8) stmt -> . iterationStmt
    (9) stmt -> . returnStmt SEMCOL
    (10) stmt -> . inputStmt SEMCOL
    (11) stmt -> . outputStmt SEMCOL
    (12) stmt -> . lineComment
    (13) stmt -> . blockComment
    (33) exprStmt -> . simpleExpr
    (14) declar -> . varDeclar SEMCOL
    (15) declar -> . funcDeclar
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call
    (34) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (36) iterationStmt -> . WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (37) returnStmt -> . RETURN
    (38) returnStmt -> . RETURN simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (64) outputStmt -> . PRINT LPARENT STRING RPARENT
    (65) lineComment -> . LINE_COMMENT
    (66) blockComment -> . BLOCK_COMMENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (16) varDeclar -> . VAR ID ASSIGN STRING
    (17) varDeclar -> . LET ID ASSIGN STRING
    (18) varDeclar -> . VAR ID ASSIGN exprStmt
    (19) varDeclar -> . LET ID ASSIGN exprStmt
    (20) varDeclar -> . VAR ID ASSIGN inputStmt
    (21) varDeclar -> . LET ID ASSIGN inputStmt
    (22) varDeclar -> . ID ASSIGN exprStmt
    (23) funcDeclar -> . FUNC ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> . FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER

    ID              shift and go to state 22
    IF              shift and go to state 19
    WHILE           shift and go to state 9
    RETURN          shift and go to state 23
    READLINE        shift and go to state 16
    PRINT           shift and go to state 7
    LINE_COMMENT    shift and go to state 8
    BLOCK_COMMENT   shift and go to state 28
    VAR             shift and go to state 26
    LET             shift and go to state 12
    FUNC            shift and go to state 17
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30

    sumExpr                        shift and go to state 5
    funcDeclar                     shift and go to state 1
    outputStmt                     shift and go to state 20
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    inputStmt                      shift and go to state 4
    suite                          shift and go to state 109
    declar                         shift and go to state 29
    call                           shift and go to state 6
    simpleExpr                     shift and go to state 3
    andExpr                        shift and go to state 27
    relExpr                        shift and go to state 10
    selectionStmt                  shift and go to state 11
    exprStmt                       shift and go to state 14
    returnStmt                     shift and go to state 31
    lineComment                    shift and go to state 13
    unaryRelExpr                   shift and go to state 33
    iterationStmt                  shift and go to state 15
    blockComment                   shift and go to state 34
    varDeclar                      shift and go to state 32
    stmt                           shift and go to state 35

state 105

    (23) funcDeclar -> FUNC ID LPARENT RPARENT LBRACK . suite RBRACK
    (2) suite -> . stmt
    (3) suite -> . stmt suite
    (4) stmt -> . exprStmt
    (5) stmt -> . declar
    (6) stmt -> . call SEMCOL
    (7) stmt -> . selectionStmt
    (8) stmt -> . iterationStmt
    (9) stmt -> . returnStmt SEMCOL
    (10) stmt -> . inputStmt SEMCOL
    (11) stmt -> . outputStmt SEMCOL
    (12) stmt -> . lineComment
    (13) stmt -> . blockComment
    (33) exprStmt -> . simpleExpr
    (14) declar -> . varDeclar SEMCOL
    (15) declar -> . funcDeclar
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call
    (34) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (36) iterationStmt -> . WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (37) returnStmt -> . RETURN
    (38) returnStmt -> . RETURN simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (64) outputStmt -> . PRINT LPARENT STRING RPARENT
    (65) lineComment -> . LINE_COMMENT
    (66) blockComment -> . BLOCK_COMMENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (16) varDeclar -> . VAR ID ASSIGN STRING
    (17) varDeclar -> . LET ID ASSIGN STRING
    (18) varDeclar -> . VAR ID ASSIGN exprStmt
    (19) varDeclar -> . LET ID ASSIGN exprStmt
    (20) varDeclar -> . VAR ID ASSIGN inputStmt
    (21) varDeclar -> . LET ID ASSIGN inputStmt
    (22) varDeclar -> . ID ASSIGN exprStmt
    (23) funcDeclar -> . FUNC ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> . FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER

    ID              shift and go to state 22
    IF              shift and go to state 19
    WHILE           shift and go to state 9
    RETURN          shift and go to state 23
    READLINE        shift and go to state 16
    PRINT           shift and go to state 7
    LINE_COMMENT    shift and go to state 8
    BLOCK_COMMENT   shift and go to state 28
    VAR             shift and go to state 26
    LET             shift and go to state 12
    FUNC            shift and go to state 17
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30

    sumExpr                        shift and go to state 5
    funcDeclar                     shift and go to state 1
    outputStmt                     shift and go to state 20
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    inputStmt                      shift and go to state 4
    suite                          shift and go to state 110
    declar                         shift and go to state 29
    call                           shift and go to state 6
    simpleExpr                     shift and go to state 3
    andExpr                        shift and go to state 27
    relExpr                        shift and go to state 10
    selectionStmt                  shift and go to state 11
    exprStmt                       shift and go to state 14
    returnStmt                     shift and go to state 31
    lineComment                    shift and go to state 13
    unaryRelExpr                   shift and go to state 33
    iterationStmt                  shift and go to state 15
    blockComment                   shift and go to state 34
    varDeclar                      shift and go to state 32
    stmt                           shift and go to state 35

state 106

    (24) funcDeclar -> FUNC ID LPARENT params RPARENT . LBRACK suite RBRACK

    LBRACK          shift and go to state 111


state 107

    (34) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK . suite RBRACK
    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK . suite RBRACK ELSE LBRACK suite RBRACK
    (2) suite -> . stmt
    (3) suite -> . stmt suite
    (4) stmt -> . exprStmt
    (5) stmt -> . declar
    (6) stmt -> . call SEMCOL
    (7) stmt -> . selectionStmt
    (8) stmt -> . iterationStmt
    (9) stmt -> . returnStmt SEMCOL
    (10) stmt -> . inputStmt SEMCOL
    (11) stmt -> . outputStmt SEMCOL
    (12) stmt -> . lineComment
    (13) stmt -> . blockComment
    (33) exprStmt -> . simpleExpr
    (14) declar -> . varDeclar SEMCOL
    (15) declar -> . funcDeclar
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call
    (34) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (36) iterationStmt -> . WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (37) returnStmt -> . RETURN
    (38) returnStmt -> . RETURN simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (64) outputStmt -> . PRINT LPARENT STRING RPARENT
    (65) lineComment -> . LINE_COMMENT
    (66) blockComment -> . BLOCK_COMMENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (16) varDeclar -> . VAR ID ASSIGN STRING
    (17) varDeclar -> . LET ID ASSIGN STRING
    (18) varDeclar -> . VAR ID ASSIGN exprStmt
    (19) varDeclar -> . LET ID ASSIGN exprStmt
    (20) varDeclar -> . VAR ID ASSIGN inputStmt
    (21) varDeclar -> . LET ID ASSIGN inputStmt
    (22) varDeclar -> . ID ASSIGN exprStmt
    (23) funcDeclar -> . FUNC ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> . FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER

    ID              shift and go to state 22
    IF              shift and go to state 19
    WHILE           shift and go to state 9
    RETURN          shift and go to state 23
    READLINE        shift and go to state 16
    PRINT           shift and go to state 7
    LINE_COMMENT    shift and go to state 8
    BLOCK_COMMENT   shift and go to state 28
    VAR             shift and go to state 26
    LET             shift and go to state 12
    FUNC            shift and go to state 17
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30

    sumExpr                        shift and go to state 5
    funcDeclar                     shift and go to state 1
    outputStmt                     shift and go to state 20
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    inputStmt                      shift and go to state 4
    suite                          shift and go to state 112
    declar                         shift and go to state 29
    call                           shift and go to state 6
    simpleExpr                     shift and go to state 3
    andExpr                        shift and go to state 27
    relExpr                        shift and go to state 10
    selectionStmt                  shift and go to state 11
    exprStmt                       shift and go to state 14
    returnStmt                     shift and go to state 31
    lineComment                    shift and go to state 13
    unaryRelExpr                   shift and go to state 33
    iterationStmt                  shift and go to state 15
    blockComment                   shift and go to state 34
    varDeclar                      shift and go to state 32
    stmt                           shift and go to state 35

state 108

    (26) paramsList -> ID COMA paramsList .

    RPARENT         reduce using rule 26 (paramsList -> ID COMA paramsList .)


state 109

    (36) iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite . RBRACK

    RBRACK          shift and go to state 113


state 110

    (23) funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite . RBRACK

    RBRACK          shift and go to state 114


state 111

    (24) funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK . suite RBRACK
    (2) suite -> . stmt
    (3) suite -> . stmt suite
    (4) stmt -> . exprStmt
    (5) stmt -> . declar
    (6) stmt -> . call SEMCOL
    (7) stmt -> . selectionStmt
    (8) stmt -> . iterationStmt
    (9) stmt -> . returnStmt SEMCOL
    (10) stmt -> . inputStmt SEMCOL
    (11) stmt -> . outputStmt SEMCOL
    (12) stmt -> . lineComment
    (13) stmt -> . blockComment
    (33) exprStmt -> . simpleExpr
    (14) declar -> . varDeclar SEMCOL
    (15) declar -> . funcDeclar
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call
    (34) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (36) iterationStmt -> . WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (37) returnStmt -> . RETURN
    (38) returnStmt -> . RETURN simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (64) outputStmt -> . PRINT LPARENT STRING RPARENT
    (65) lineComment -> . LINE_COMMENT
    (66) blockComment -> . BLOCK_COMMENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (16) varDeclar -> . VAR ID ASSIGN STRING
    (17) varDeclar -> . LET ID ASSIGN STRING
    (18) varDeclar -> . VAR ID ASSIGN exprStmt
    (19) varDeclar -> . LET ID ASSIGN exprStmt
    (20) varDeclar -> . VAR ID ASSIGN inputStmt
    (21) varDeclar -> . LET ID ASSIGN inputStmt
    (22) varDeclar -> . ID ASSIGN exprStmt
    (23) funcDeclar -> . FUNC ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> . FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER

    ID              shift and go to state 22
    IF              shift and go to state 19
    WHILE           shift and go to state 9
    RETURN          shift and go to state 23
    READLINE        shift and go to state 16
    PRINT           shift and go to state 7
    LINE_COMMENT    shift and go to state 8
    BLOCK_COMMENT   shift and go to state 28
    VAR             shift and go to state 26
    LET             shift and go to state 12
    FUNC            shift and go to state 17
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30

    sumExpr                        shift and go to state 5
    funcDeclar                     shift and go to state 1
    outputStmt                     shift and go to state 20
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    inputStmt                      shift and go to state 4
    suite                          shift and go to state 115
    declar                         shift and go to state 29
    call                           shift and go to state 6
    simpleExpr                     shift and go to state 3
    andExpr                        shift and go to state 27
    relExpr                        shift and go to state 10
    selectionStmt                  shift and go to state 11
    exprStmt                       shift and go to state 14
    returnStmt                     shift and go to state 31
    lineComment                    shift and go to state 13
    unaryRelExpr                   shift and go to state 33
    iterationStmt                  shift and go to state 15
    blockComment                   shift and go to state 34
    varDeclar                      shift and go to state 32
    stmt                           shift and go to state 35

state 112

    (34) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite . RBRACK
    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite . RBRACK ELSE LBRACK suite RBRACK

    RBRACK          shift and go to state 116


state 113

    (36) iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .

    ID              reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    IF              reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    WHILE           reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    RETURN          reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    READLINE        reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    PRINT           reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    LINE_COMMENT    reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    BLOCK_COMMENT   reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    VAR             reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    LET             reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    FUNC            reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    NOT             reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    NUMBER          reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    RBRACK          reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    $end            reduce using rule 36 (iterationStmt -> WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)


state 114

    (23) funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .

    ID              reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    IF              reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    WHILE           reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    RETURN          reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    READLINE        reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    PRINT           reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    LINE_COMMENT    reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    BLOCK_COMMENT   reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    VAR             reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    LET             reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    FUNC            reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    NOT             reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    NUMBER          reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    RBRACK          reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)
    $end            reduce using rule 23 (funcDeclar -> FUNC ID LPARENT RPARENT LBRACK suite RBRACK .)


state 115

    (24) funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite . RBRACK

    RBRACK          shift and go to state 117


state 116

    (34) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .
    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK . ELSE LBRACK suite RBRACK

    ID              reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    IF              reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    WHILE           reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    RETURN          reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    READLINE        reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    PRINT           reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    LINE_COMMENT    reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    BLOCK_COMMENT   reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    VAR             reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    LET             reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    FUNC            reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    NOT             reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    NUMBER          reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    RBRACK          reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    $end            reduce using rule 34 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK .)
    ELSE            shift and go to state 118


state 117

    (24) funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .

    ID              reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    IF              reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    WHILE           reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    RETURN          reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    READLINE        reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    PRINT           reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    LINE_COMMENT    reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    BLOCK_COMMENT   reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    VAR             reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    LET             reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    FUNC            reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    NOT             reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    NUMBER          reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    RBRACK          reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)
    $end            reduce using rule 24 (funcDeclar -> FUNC ID LPARENT params RPARENT LBRACK suite RBRACK .)


state 118

    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE . LBRACK suite RBRACK

    LBRACK          shift and go to state 119


state 119

    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK . suite RBRACK
    (2) suite -> . stmt
    (3) suite -> . stmt suite
    (4) stmt -> . exprStmt
    (5) stmt -> . declar
    (6) stmt -> . call SEMCOL
    (7) stmt -> . selectionStmt
    (8) stmt -> . iterationStmt
    (9) stmt -> . returnStmt SEMCOL
    (10) stmt -> . inputStmt SEMCOL
    (11) stmt -> . outputStmt SEMCOL
    (12) stmt -> . lineComment
    (13) stmt -> . blockComment
    (33) exprStmt -> . simpleExpr
    (14) declar -> . varDeclar SEMCOL
    (15) declar -> . funcDeclar
    (28) call -> . ID
    (29) call -> . ID POINT call
    (30) call -> . ID LPARENT RPARENT
    (31) call -> . ID LPARENT params RPARENT
    (32) call -> . call POINT call
    (34) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (35) selectionStmt -> . IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK
    (36) iterationStmt -> . WHILE LPARENT simpleExpr RPARENT LBRACK suite RBRACK
    (37) returnStmt -> . RETURN
    (38) returnStmt -> . RETURN simpleExpr
    (63) inputStmt -> . READLINE LPARENT RPARENT
    (64) outputStmt -> . PRINT LPARENT STRING RPARENT
    (65) lineComment -> . LINE_COMMENT
    (66) blockComment -> . BLOCK_COMMENT
    (39) simpleExpr -> . simpleExpr OR andExpr
    (40) simpleExpr -> . andExpr
    (16) varDeclar -> . VAR ID ASSIGN STRING
    (17) varDeclar -> . LET ID ASSIGN STRING
    (18) varDeclar -> . VAR ID ASSIGN exprStmt
    (19) varDeclar -> . LET ID ASSIGN exprStmt
    (20) varDeclar -> . VAR ID ASSIGN inputStmt
    (21) varDeclar -> . LET ID ASSIGN inputStmt
    (22) varDeclar -> . ID ASSIGN exprStmt
    (23) funcDeclar -> . FUNC ID LPARENT RPARENT LBRACK suite RBRACK
    (24) funcDeclar -> . FUNC ID LPARENT params RPARENT LBRACK suite RBRACK
    (41) andExpr -> . andExpr AND unaryRelExpr
    (42) andExpr -> . unaryRelExpr
    (43) unaryRelExpr -> . NOT unaryRelExpr
    (44) unaryRelExpr -> . relExpr
    (45) relExpr -> . sumExpr relop sumExpr
    (46) relExpr -> . sumExpr
    (53) sumExpr -> . sumExpr sumop term
    (54) sumExpr -> . term
    (57) term -> . term mulop opElement
    (58) term -> . opElement
    (59) opElement -> . call
    (60) opElement -> . NUMBER

    ID              shift and go to state 22
    IF              shift and go to state 19
    WHILE           shift and go to state 9
    RETURN          shift and go to state 23
    READLINE        shift and go to state 16
    PRINT           shift and go to state 7
    LINE_COMMENT    shift and go to state 8
    BLOCK_COMMENT   shift and go to state 28
    VAR             shift and go to state 26
    LET             shift and go to state 12
    FUNC            shift and go to state 17
    NOT             shift and go to state 25
    NUMBER          shift and go to state 30

    sumExpr                        shift and go to state 5
    funcDeclar                     shift and go to state 1
    outputStmt                     shift and go to state 20
    opElement                      shift and go to state 21
    term                           shift and go to state 2
    inputStmt                      shift and go to state 4
    suite                          shift and go to state 120
    declar                         shift and go to state 29
    call                           shift and go to state 6
    simpleExpr                     shift and go to state 3
    andExpr                        shift and go to state 27
    relExpr                        shift and go to state 10
    selectionStmt                  shift and go to state 11
    exprStmt                       shift and go to state 14
    returnStmt                     shift and go to state 31
    lineComment                    shift and go to state 13
    unaryRelExpr                   shift and go to state 33
    iterationStmt                  shift and go to state 15
    blockComment                   shift and go to state 34
    varDeclar                      shift and go to state 32
    stmt                           shift and go to state 35

state 120

    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite . RBRACK

    RBRACK          shift and go to state 121


state 121

    (35) selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .

    ID              reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    IF              reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    WHILE           reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    RETURN          reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    READLINE        reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    PRINT           reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    LINE_COMMENT    reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    BLOCK_COMMENT   reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    VAR             reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    LET             reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    FUNC            reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    NOT             reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    NUMBER          reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    RBRACK          reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)
    $end            reduce using rule 35 (selectionStmt -> IF LPARENT simpleExpr RPARENT LBRACK suite RBRACK ELSE LBRACK suite RBRACK .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for POINT in state 22 resolved as shift
WARNING: shift/reduce conflict for POINT in state 65 resolved as shift
WARNING: shift/reduce conflict for POINT in state 76 resolved as shift
WARNING: shift/reduce conflict for POINT in state 88 resolved as shift
